#!/usr/bin/env python2

from joerntools.shelltool.AccTool import AccTool

"""
- Both forward and backward slices can be calculated. The exact
behaviour depends on the node type.

- Statements/Conditions: The slice is calculated for all symbols
  used/defined by the statement.

- Arguments: The slice is calculated for all symbols used/defined in
  the specified argument.

- Callees: The forward slice is calculated for all symbols
  occuring on the left hand side of the assignment (return value), the
  backward slice is calculated for the statement.

In summary, this allows the following kinds of slices to be extracted: 

- Forward/backward slices considering all symbols
- Forward slices considering function return values
- Forward/backward slices for symbols occuring in the i'th argument of
  calls.

Output format:
==============

label TAB NodeId_1 ... NodeId_m TAB EdgeId_1 .... EdgeId_n
"""

DESCRIPTION = """Extracts program slices."""

class SliceTool(AccTool):
    pass

    def __init__(self, DESCRIPTION):
        AccTool.__init__(self, DESCRIPTION)
        
        self.argParser.add_argument(
            '-s', '--slice-direction',
            action = 'store',
            choices = ['forward', 'backwards'],
            default = 'forward',
            help = """The slicing direction""")

        self.argParser.add_argument(
            '-l', '--label',
            action = 'store',
            default = "it.id",
            help = """Traversal for labeling""")

    
    def processBatch(self, nodeIds):

        query = self._createQueryForNode(nodeIds)
        
        for (seedPointId, nodeIds, edgeIds) in self._runGremlinQuery(query):
            
            nodeIdStr = ' '.join([str(x) for x in nodeIds])
            edgeIdStr = ' '.join([str(x) for x in edgeIds])

            self.output(str(seedPointId) + "\t" + nodeIdStr + "\t" + edgeIdStr + "\n")
        
    def _createQueryForNode(self, nodeIds):
        if self.args.slice_direction == 'forward':
            return self._createForwardQueryForNode(nodeIds)
        else:
            return self._createBackwardQueryForNode(nodeIds)
    
    def _createForwardQueryForNode(self, nodeIds):
        
        forwardQuery = """
        idListToNodes(%s)
        .sideEffect
        {
           seedNodeId = %s;

           if(it.type == 'Callee'){
        
    		symbols = it.matchParents{it.type == 'AssignmentExpr'}
			  .lval().code.toList()
        
           } else if(it.type == 'Argument'){
                 symbols = it.defines().code.toList()
           } else{
                 symbols = it.statements().out('USE', 'DEF').code.toList()
           }
        }.statements().transform{
            nodes = it.forwardSlice(symbols).id.toList()
            [seedNodeId, nodes, idListToNodes(nodes).outE().id.toList() ]
        }
        """ % (nodeIds, self.args.label)
        
        return forwardQuery

    def _createBackwardQueryForNode(self, nodeIds):
        
        backwardQuery = """
        idListToNodes(%s)
        .sideEffect
        {
          seedNodeId = %s;

          if(it.type == 'Argument'){
                 symbols = it.uses().code.toList()
           } else{
                 symbols = it.statements().out('USE', 'DEF').code.toList()
            }
        }.statements().transform{
            nodes = it.backwardSlice(symbols).id.toList()
            [seedNodeId, nodes, idListToNodes(nodes).outE().id.toList() ]
        }
        """ % (nodeIds, self.args.label)
        
        return backwardQuery
       
if __name__ == '__main__':
    tool = SliceTool(DESCRIPTION)
    tool.run()
