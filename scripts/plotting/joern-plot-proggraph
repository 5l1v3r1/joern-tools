#!/usr/bin/env python3

import pygraphviz as pgv
from octopus.server.DBInterface import DBInterface

from joern.shelltool.JoernTool import JoernTool
from octopus.shelltool.ResultProcessor import BaseResultProcessor

DESCRIPTION = """Retrieve a graph representation of a function with the given
id. The default output format is graphviz's 'dot'.
"""

class NodeResult(BaseResultProcessor):
    def getId(self):
        return self.result['id']
    def getNodeProperties(self):
        props = self.properties()
        props['id'] = self.getId()
        return props
    def getPlotProperties(self):
        props = {
            "shape" : "rectangle",
            'style' : 'filled',
            'fillcolor' : 'lightcyan'
        }
        if self.value(self.result,'type') == 'CFGEntryNode':
            props['fillcolor'] = "slategrey"
            props['fontcolor'] = "white"
        if self.value(self.result,'type') == 'CFGExitNode':
            props['fillcolor'] = "black"
            props['fontcolor'] = "white"
        return props

class EdgeResult(BaseResultProcessor):
    def getDest(self):
        return self.result['outV']
    def getSrc(self):
        return self.result['inV']
    def getKey(self):
        return self.result['id']
    def getLabel(self):
        return self.result['label']
    def getPlotProperties(self):
        props = { }
        if self.result['label'] == 'FLOWS_TO':
            props['color'] = 'black'
            props['fontcolor'] = 'black'
        elif self.result['label'] == 'CONTROLS':
            props['color'] = 'slategrey'
            props['fontcolor'] = 'slategrey'
        elif self.result['label'] == 'DOM':
            props['color'] = 'sandybrown'
            props['fontcolor'] = 'sandybrown'
        elif self.result['label'] == 'POST_DOM':
            props['color'] = 'tomato'
            props['fontcolor'] = 'tomato'
        elif self.result['label'] == 'REACHES':
            props['color'] = 'darkviolet'
            props['fontcolor'] = 'darkviolet'
        return props



class ProgramGraph(JoernTool):
    def __init__(self):
        JoernTool.__init__(self, DESCRIPTION)

        self.argParser.add_argument('-a', '--attributes',
                                    nargs='+', type=str,
                                    help="""Attributes shown in each node.""",
                                    default=[])

        self.argParser.add_argument('-ddg', '--show-data-dependences',
                                    action='store_true',
                                    help="""Show data dependences.""",
                                    default=False)

        self.argParser.add_argument('-cdg', '--show-control-dependences',
                                    action='store_true',
                                    help="""Show control dependences.""",
                                    default=False)

        self.argParser.add_argument('-dom', '--show-dominance-edges',
                                    action='store_true',
                                    help="""Show dominance edges.""",
                                    default=False)

        self.argParser.add_argument('-all', '--show-all',
                                    action='store_true',
                                    help="""Show all edge types""",
                                    default=False)

        self.argParser.add_argument('-P','--id-property',action='store_true', default=False,
                                    help="use functionId property value to identify function")

        self.argParser.add_argument('-k','--show-keys',action='store_true', default=False,
                                    help="show both property keys and values instead of just values")

    # @Override
    def processLine(self, line):
        labels = self._getLabels()
        nodes = self._getNodes(int(line), labels)
        edges = self._getEdges(int(line), labels)

        G = pgv.AGraph(directed=True, strict=False)
        self._addNodes(G, nodes)
        self._addEdges(G, edges)
        self._outputGraph(G, line)

    def streamStart(self):
        self.dbInterface = DBInterface()
        self.dbInterface.connectToDatabase(self.args.project)

    def _addNodes(self, G, nodes):
        for v in nodes:
            nr = NodeResult(v)
            label = self._createNodeLabel(nr.getNodeProperties())
            plotproperties = nr.getPlotProperties()
            if label:
                plotproperties['label'] = label
            G.add_node(nr.getId(), **plotproperties)

    def _addEdges(self, G, edges):
        for e in edges:
            er = EdgeResult(e)
            plot_properties = er.getPlotProperties()
            plot_properties['label'] = er.getLabel()
            G.add_edge(er.getDest(), er.getSrc(), er.getKey(), **plot_properties)

    def _createNodeLabel(self, nodeProperties):
        labels = []
        if self.args.attributes == []:
            attrs = nodeProperties.keys()
        else:
            attrs = self.args.attributes
        for attribute in attrs:
            try:
                if self.args.show_keys:
                    lab = attribute+":"
                else:
                    lab = ""
                lab += str(nodeProperties[attribute])
                labels.append(lab)
            except KeyError:
                pass
        labels = filter(None, labels)
        return '\n'.join(labels)

    def _outputGraph(self, G, identifier):

        ENDMARKER = '//###'
        self.output('//' + identifier + '\n')
        self.output(str(G) + '\n')
        self.output(ENDMARKER + '\n')

    def _getLabels(self):
        labels = ["FLOWS_TO", "REACHES", "CONTROLS", "DOM", "POST_DOM"]
        if self.args.show_all:
            return labels

        if not self.args.show_data_dependences:
            labels.remove("REACHES")
        if not self.args.show_control_dependences:
            labels.remove("CONTROLS")
        if not self.args.show_dominance_edges:
            labels.remove("DOM")
            labels.remove("POST_DOM")

        return labels

    def _getStartNode(self,functionId):
        if self.args.id_property:
            startnode = """g.V().has('functionId','{}').has('type','CFGEntryNode')""".format(functionId)
        else:
            startnode = """g.V({}).out('IS_FUNCTION_OF_CFG')""".format(functionId)
        return startnode

    def _getNodes(self, functionId, labels):
        query = """
            {}.repeat(outE({}).subgraph('sg').inV().simplePath()).cap('sg').next().traversal().V()
            """.format( self._getStartNode(functionId), ','.join(map(lambda x: "'{}'".format(x), labels)))
        return self._runGremlinQuery(query)

    def _getEdges(self, functionId, labels):
        query = """
            {}.repeat(outE({}).subgraph('sg').inV().simplePath()).cap('sg').next().traversal().E()
            """.format( self._getStartNode(functionId), ','.join(map(lambda x: "'{}'".format(x), labels)))
        return self._runGremlinQuery(query)


if __name__ == '__main__':
    tool = ProgramGraph()
    tool.run()
