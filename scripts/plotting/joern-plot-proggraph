#!/usr/bin/env python3

import pygraphviz as pgv
from octopus.server.DBInterface import DBInterface

from joern.shelltool.JoernTool import JoernTool

DESCRIPTION = """Retrieve a graph representation of a function with the given
id. The default output format is graphviz's 'dot'.
"""


class ProgramGraph(JoernTool):
    def __init__(self):
        JoernTool.__init__(self, DESCRIPTION)

        self.argParser.add_argument('-a', '--attributes',
                                    nargs='+', type=str,
                                    help="""Attributes shown in each node.""",
                                    default=[])

        self.argParser.add_argument('-ddg', '--show-data-dependences',
                                    action='store_true',
                                    help="""Show data dependences.""",
                                    default=False)

        self.argParser.add_argument('-cdg', '--show-control-dependences',
                                    action='store_true',
                                    help="""Show control dependences.""",
                                    default=False)

        self.argParser.add_argument('-dom', '--show-dominance-edges',
                                    action='store_true',
                                    help="""Show dominance edges.""",
                                    default=False)

        self.argParser.add_argument('-all', '--show-all',
                                    action='store_true',
                                    help="""Show all edge types""",
                                    default=False)

    # @Override
    def processLine(self, line):
        labels = self._getLabels()
        nodes = self._getNodes(int(line), labels)
        edges = self._getEdges(int(line), labels)

        G = pgv.AGraph(directed=True, strict=False)
        self._addNodes(G, nodes)
        self._addEdges(G, edges)
        self._outputGraph(G, line)

    def streamStart(self):
        self.dbInterface = DBInterface()
        self.dbInterface.connectToDatabase(self.args.project)

    def _addNodes(self, G, nodes):
        for v in nodes:
            label = self._createNodeLabel(v['properties'])
            if label:
                v['label'] = label
            G.add_node(v['id'], **v)

    def _addEdges(self, G, edges):
        for e in edges:
            G.add_edge(e['outV'], e['inV'], key=e['id'], **e)

    def _createNodeLabel(self, nodeProperties):
        labels = []
        for attribute in self.args.attributes:
            try:
                labels.append(nodeProperties[attribute][0]['value'])
            except KeyError:
                pass
        labels = filter(None, labels)
        return '\n'.join(labels)

    def _outputGraph(self, G, identifier):

        ENDMARKER = '//###'
        self.output('//' + identifier + '\n')
        self.output(str(G) + '\n')
        self.output(ENDMARKER + '\n')

    def _getLabels(self):
        labels = ["FLOWS_TO", "REACHES", "CONTROLS", "DOM", "POST_DOM"]
        if self.args.show_all:
            return labels

        if not self.args.show_data_dependences:
            labels.remove("REACHES")
        if not self.args.show_control_dependences:
            labels.remove("CONTROLS")
        if not self.args.show_dominance_edges:
            labels.remove("DOM")
            labels.remove("POST_DOM")

        return labels

    def _getNodes(self, functionId, labels):
        query = "g.V({}).out('IS_FUNCTION_OF_CFG').repeat(outE({}).subgraph('sg').inV().simplePath()).cap(" \
                "'sg').next().traversal().V()".format(
            functionId, ','.join(map(lambda x: "'{}'".format(x), labels)))
        return self._runGremlinQuery(query)

    def _getEdges(self, functionId, labels):
        query = "g.V({}).out('IS_FUNCTION_OF_CFG').repeat(outE({}).subgraph('sg').inV().simplePath()).cap(" \
                "'sg').next().traversal().E()".format(
            functionId, ','.join(map(lambda x: "'{}'".format(x), labels)))
        return self._runGremlinQuery(query)


if __name__ == '__main__':
    tool = ProgramGraph()
    tool.run()
